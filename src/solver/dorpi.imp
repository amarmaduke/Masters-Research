namespace {

struct scale_functor
{
  scale_functor(double v) : val(v) { }

  __host__ __device__
  void operator()(double& x) const {
     x *= val;
  }
  private:
    double val;
};

struct max_absolute_functor
{
  __host__ __device__
  bool operator()(double lhs, double rhs)
  {
    return abs(lhs) < abs(rhs);
  }
};

struct square_functor
{
  __host__ __device__
  double operator()(double x)
  {
    return x*x;
  }
};

 // anonymous namespace

void print1(thrust::host_vector<thrust::device_ptr<double> > vecs, thrust::host_vector<double> c, int ptr_size)
{
	std::cout << "vecs:" << std::endl;
	for(int i = 0; i < vecs.size(); ++i)
	{
		for(int j = 0; j < ptr_size; ++j)
		{
			std::cout << vecs[i][j] << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "constants:" << std::endl;
	for(int i = 0; i < c.size(); ++i)
	{
		std::cout << c[i] << " ";
	}
	std::cout << std::endl;
}

}

#define d(x,y) (double)((x))/(double)((y))

template<typename F>
thrust::host_vector<thrust::device_ptr<double> >
solve(F functor, double t_i, thrust::device_ptr<double>& y_init, int ptr_size,
      const options& o)
{
	///*
double y_constants[7][7] = {
{      1./2.,            0,           0,         0,              0,          0,    0},
{      d(3,40),       d(9,40),           0,         0,              0,          0,    0},
{     d(44,45),     d(-56,15),      d(32,9),         0,              0,          0,    0},
{d(19372,6561),d(-25360,2187),d(64448,6561),d(-212,729),              0,          0,    0},
{ d(9017,3168),    d(-355,33),d(46732,5247),  d(49,176),  d(-5103,18656),          0,    0},
{    d(35,384),            0,  d(500,1113), d(125,192),   d(-2187,6784),    d(11,84),    0},
{d(5179,57600),            0,d(7571,16695),d(393,640),d(-92097,339200),d(187,2100),d(1,40)}};
	//*/

/*
double ** y_constants = new double*[7];
for(int i = 0; i < 7; ++i)
{
	y_constants[i] = new double[7]();
}
*/

double t_constants[6] = {d(1,5), d(3,10),d(4,5), d(8,9), 1, 1};

	//util::print(y_init,ptr_size);
  // Output vector
  thrust::host_vector<thrust::device_ptr<double> > output;

  // Setup for Dormand-Prince function evaluations
  thrust::host_vector<thrust::device_ptr<double> > k(8);
  thrust::host_vector<double> constants(9);
  constants[0] = 1;

  thrust::device_ptr<double> temp_y;

  thrust::device_ptr<double> y = thrust::device_malloc<double>(ptr_size);
	util::deep_copy<double>(y,y_init,ptr_size);

  cublasHandle_t handle;
  cublasCreate(&handle);

  double t = t_i, h = o.requested_h;
  bool done = false;

	double save_stop = t;
	double save_freq = (o.t_end - t) / o.save_count;

  // Initial force evaluation
  k[0] = functor(t, y);

  do
  {
    bool failed = false;
    double temp_t, err;

    if(h >= 1.1*abs(o.t_end - t))
    {
			std::cout << "pre 10% scale h: " << h << std::endl;
      h = o.t_end - t;
      std::cout << "post 10% scale h: " << h << std::endl;
			done = true;
    }

		if(t >= save_stop)
		{
			thrust::device_ptr<double> save = thrust::device_malloc<double>(ptr_size);
			util::deep_copy(save,y,ptr_size);
			output.push_back(save);
			save_stop += save_freq;
		}

		std::cout << "t: " << t << " h: " << h << " t_end: " << o.t_end << std::endl;
		thrust::device_ptr<double> save = thrust::device_malloc<double>(ptr_size);
    while(true)
    {
      thrust::host_vector<thrust::device_ptr<double> > vecs;

      // Function Evaluations

			thrust::copy_n(y_constants[0],1,constants.begin()+1);
			thrust::for_each_n(constants.begin()+1,1,scale_functor(h));
      vecs.push_back(y); vecs.push_back(k[0]);

			//std::cout << "k[1]:" << std::endl;
			temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[0];
      k[1] = functor(temp_t, temp_y);
			thrust::device_free(temp_y);
			//std::cout << std::endl;

			//std::cout << "k[2]:" << std::endl;
      thrust::copy_n(&y_constants[1][0],2,constants.begin()+1);
      thrust::for_each_n(constants.begin()+1,2,scale_functor(h));
      vecs.push_back(k[1]);
      temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[1];
      k[2] = functor(temp_t, temp_y);
      thrust::device_free(temp_y);
			//util::print(k[2],ptr_size);
			//std::cout << std::endl;

			//std::cout << "k[3]:" << std::endl;
      thrust::copy_n(&y_constants[2][0],3,constants.begin()+1);
      thrust::for_each_n(constants.begin()+1,3,scale_functor(h));
      vecs.push_back(k[2]);
      temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[2];
      k[3] = functor(temp_t, temp_y);
      thrust::device_free(temp_y);
			//util::print(k[3],ptr_size);
			//std::cout << std::endl;

			//std::cout << "k[4]:" << std::endl;
      thrust::copy_n(&y_constants[3][0],4,constants.begin()+1);
      thrust::for_each_n(constants.begin()+1,4,scale_functor(h));
      vecs.push_back(k[3]);
      temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[3];
      k[4] = functor(temp_t, temp_y);
      thrust::device_free(temp_y);
			//util::print(k[4],ptr_size);
			//std::cout << std::endl;

			//std::cout << "k[5]:" << std::endl;
      thrust::copy_n(&y_constants[4][0],5,constants.begin()+1);
      thrust::for_each_n(constants.begin()+1,5,scale_functor(h));
      vecs.push_back(k[4]);
      temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[4];
      k[5] = functor(temp_t, temp_y);
      thrust::device_free(temp_y);
			//util::print(k[5],ptr_size);
			//std::cout << std::endl;

			//std::cout << "k[6]:" << std::endl;
      thrust::copy_n(&y_constants[5][0],6,constants.begin()+1);
      thrust::for_each_n(constants.begin()+1,6,scale_functor(h));
      vecs.push_back(k[5]);
      temp_y = util::linc(handle,ptr_size,constants,vecs);
      temp_t = t + h*t_constants[5];
      k[6] = functor(temp_t, temp_y);
			//util::print(k[6],ptr_size);
			//std::cout << std::endl;

      double tnew = temp_t;
      h = tnew - t;
      thrust::device_ptr<double> error_vec;

			//util::print(k[6],ptr_size);

			// Compute Error
      thrust::copy_n(&y_constants[6][0],7,constants.begin()+1);
      vecs.push_back(k[6]);
			//for(int i = 0; i < vecs.size(); ++i)
			//{
			//	util::print(vecs[i],ptr_size);
			//}
      error_vec = util::linc(handle,ptr_size,constants,vecs);
      //util::print(error_vec,ptr_size);

			thrust::device_ptr<double> d_max_y = thrust::max_element( y,y + ptr_size,
                                          max_absolute_functor());
			double * max_y = new double;
			double * max_ynew = new double;
			util::deep_copy(max_y,d_max_y,1);
      thrust::device_ptr<double> d_max_ynew = thrust::max_element(temp_y, temp_y + ptr_size,
                                            max_absolute_functor());
			util::deep_copy(max_ynew,d_max_ynew,1);
      //std::cout << *max_y << " " << *max_ynew << std::endl;
			std::cout << "max_y: " << abs(*max_y) << " max_ynew: " << abs(*max_ynew) << std::endl;
			double s = 1/max(max(abs(*max_y),abs(*max_ynew)),1.);
			scale_functor scale(s);
			//std::cout << "Label 1" << std::endl;
      thrust::for_each(error_vec, error_vec + ptr_size, scale);

      double norm = std::sqrt(thrust::transform_reduce(
                    error_vec, error_vec + ptr_size, square_functor(), 0,
                    thrust::plus<double>()));
      err = h*norm;
      thrust::device_free(error_vec);

      // Check Error
			std::cout << "scale s: " << s << std::endl;
			std::cout << "norm: " << norm << " err: " << err << std::endl;
			std::cout << "pre error check h: " << h << std::endl;
      if (err > o.tolerance)
      {
        if (not failed)
          failed = true;
        else
          h = .5*h;
        done = false;
      }else
      {
        break;
      }
			std::cout << "post error check h: " << h << std::endl;
    }

    // Adjust step size
		std::cout << "pre adjust step size h: " << h << std::endl;
    if (not failed)
    {
      double temp = 1.25*pow(err / o.tolerance,1./5.);
      std::cout << "temp: " << temp << std::endl;
			if (temp > .2)
        h = h / temp;
      else
        h = 5*h;
    }
		std::cout << "post adjust step size h: " << h << std::endl;

    // Update

    util::deep_copy<double>(y,temp_y,ptr_size);

    thrust::device_free(temp_y);
    t = temp_t;

    for(int i = 0; i < 6; ++i)
    {
      thrust::device_free(k[i]);
    }
    k[0] = k[6];

		int stop_point;
		scanf("%d",&stop_point);

  } while (not done);

	thrust::device_ptr<double> save = thrust::device_malloc<double>(ptr_size);
	util::deep_copy(save,y,ptr_size);
	output.push_back(save);

	// Cleanup
  thrust::device_free(k[0]);
  thrust::device_free(y);

  return output;
}
